#!/bin/bash

# Git repository cleanup utility
# Helps clean up merged branches and optimize repositories

set -e

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

show_help() {
    cat << EOF
Git Cleanup Utility

Usage: git-cleanup [options]

Options:
    --dry-run       Show what would be cleaned without making changes
    --aggressive    Also clean up remote tracking branches
    --help, -h      Show this help message

This script will:
    1. Delete local branches that have been merged into main/master
    2. Prune remote tracking branches
    3. Clean up unreachable commits (git gc)
    4. Update the default branch from remote

EOF
}

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Not in a git repository"
        exit 1
    fi
}

# Get the default branch (main or master)
get_default_branch() {
    local default_branch
    
    # Try to get default branch from remote
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    
    if [[ -z "$default_branch" ]]; then
        # Fallback: check if main or master exists
        if git show-ref --verify --quiet refs/heads/main; then
            default_branch="main"
        elif git show-ref --verify --quiet refs/heads/master; then
            default_branch="master"
        else
            print_error "Could not determine default branch"
            exit 1
        fi
    fi
    
    echo "$default_branch"
}

# Clean up merged branches
cleanup_merged_branches() {
    local dry_run="$1"
    local default_branch="$2"
    
    print_info "Cleaning up branches merged into $default_branch..."
    
    # Get list of merged branches (excluding current branch and default branch)
    local merged_branches
    merged_branches=$(git branch --merged "$default_branch" | grep -v "^\*" | grep -v "$default_branch" | xargs)
    
    if [[ -z "$merged_branches" ]]; then
        print_info "No merged branches to clean up"
        return
    fi
    
    if [[ "$dry_run" == "true" ]]; then
        print_info "Would delete the following merged branches:"
        for branch in $merged_branches; do
            echo "  - $branch"
        done
    else
        print_info "Deleting merged branches:"
        for branch in $merged_branches; do
            git branch -d "$branch"
            print_success "Deleted branch: $branch"
        done
    fi
}

# Clean up remote tracking branches
cleanup_remote_branches() {
    local dry_run="$1"
    local aggressive="$2"
    
    if [[ "$aggressive" == "true" ]]; then
        print_info "Cleaning up remote tracking branches..."
        
        if [[ "$dry_run" == "true" ]]; then
            print_info "Would prune remote tracking branches"
        else
            git remote prune origin
            print_success "Pruned remote tracking branches"
        fi
    fi
}

# Run git garbage collection
run_garbage_collection() {
    local dry_run="$1"
    
    print_info "Running garbage collection..."
    
    if [[ "$dry_run" == "true" ]]; then
        print_info "Would run: git gc --prune=now"
    else
        git gc --prune=now
        print_success "Garbage collection completed"
    fi
}

# Update default branch
update_default_branch() {
    local dry_run="$1"
    local default_branch="$2"
    local current_branch
    
    current_branch=$(git branch --show-current)
    
    print_info "Updating $default_branch from remote..."
    
    if [[ "$dry_run" == "true" ]]; then
        print_info "Would fetch and update $default_branch"
    else
        git fetch origin
        
        if [[ "$current_branch" == "$default_branch" ]]; then
            git pull origin "$default_branch"
            print_success "Updated current branch ($default_branch)"
        else
            git fetch origin "$default_branch:$default_branch"
            print_success "Updated $default_branch"
        fi
    fi
}

# Show repository status
show_status() {
    local default_branch="$1"
    
    print_info "Repository status after cleanup:"
    echo ""
    echo "Branches:"
    git branch -v
    echo ""
    echo "Repository size:"
    du -sh .git 2>/dev/null | awk '{print "  Git directory: " $1}'
}

# Main function
main() {
    local dry_run=false
    local aggressive=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                dry_run=true
                shift
                ;;
            --aggressive)
                aggressive=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    check_git_repo
    
    local default_branch
    default_branch=$(get_default_branch)
    
    print_info "Starting git cleanup (default branch: $default_branch)"
    [[ "$dry_run" == "true" ]] && print_warning "DRY RUN MODE - No changes will be made"
    echo ""
    
    update_default_branch "$dry_run" "$default_branch"
    cleanup_merged_branches "$dry_run" "$default_branch"
    cleanup_remote_branches "$dry_run" "$aggressive"
    run_garbage_collection "$dry_run"
    
    echo ""
    if [[ "$dry_run" == "false" ]]; then
        show_status "$default_branch"
        print_success "Git cleanup completed!"
    else
        print_info "Dry run completed. Use without --dry-run to apply changes."
    fi
}

main "$@"